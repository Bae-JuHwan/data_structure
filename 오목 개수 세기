#include <iostream>
#include <string>
#include <limits>

using namespace std;

#define ROW 19
#define COL 19

string map[ROW][COL];

struct Line {
	int blackStone = 0;
	int whiteStone = 0;
	int longConsecutive = 0;
	string stoneType;
};

void set() {
	for (int i = 0; i < ROW; ++i) {
		for (int j = 0; j < COL; ++j) {
			map[i][j] = "□ ";
		}
	}
}

void printMap(Line lines[ROW + COL + 2]) {
	for (int i = 0; i < ROW; ++i) {
		for (int j = 0; j < COL; ++j) {
			cout << map[i][j];
		}
		cout << "   " << i << " : 가로 b" << lines[i].blackStone << ", w" << lines[i].whiteStone <<
			",   세로 b" << lines[ROW + i].blackStone << ", w" << lines[ROW + i].whiteStone << '\n';
	}
}

void placeStone(string map[ROW][COL], int row, int col, string stone) {
	map[row][col] = stone;
}

bool isValidMove(string map[ROW][COL], int row, int col) {
	return (map[row][col] == "□ ");
}

void countStone(Line lines[ROW + COL + 2], string map[ROW][COL], int row, int col) {
	lines[row].blackStone = 0;
	lines[row].whiteStone = 0;

	lines[ROW + col].blackStone = 0;
	lines[ROW + col].whiteStone = 0;

	int blackStoneRow = 0;
	int whiteStoneRow = 0;
	int blackStoneCol = 0;
	int whiteStoneCol = 0;

	for (int i = 0; i < ROW; ++i) {
		if (map[row][i] == "● ") {
			blackStoneRow++;
		}
		else if (map[row][i] == "○ ") {
			whiteStoneRow++;
		}

		lines[row].blackStone = max(lines[row].blackStone, blackStoneRow);
		lines[row].whiteStone = max(lines[row].whiteStone, whiteStoneRow);

		if (map[i][col] == "● ") {
			blackStoneCol++;
		}
		else if (map[i][col] == "○ ") {
			whiteStoneCol++;
		}

		lines[ROW + col].blackStone = max(lines[ROW + col].blackStone, blackStoneCol);
		lines[ROW + col].whiteStone = max(lines[ROW + col].whiteStone, whiteStoneCol);
	}
}

void consecutiveStone(Line lines[ROW + COL + 2], string map[ROW][COL], int row, int col) {
	lines[row].longConsecutive = 0;
	lines[ROW + col].longConsecutive = 0;
	lines[2 * ROW].longConsecutive = 0;
	lines[2 * ROW + 1].longConsecutive = 0;

	int consecutiveBlackRow = 0;
	int consecutiveWhiteRow = 0;
	int consecutiveBlackCol = 0;
	int consecutiveWhiteCol = 0;

	int maxConsecutiveRow = -1;
	int maxConsecutiveCol = -1;
	int maxConsecutiveDiagonal1 = -1;
	int maxConsecutiveDiagonal2 = -1;

	for (int i = 0; i < ROW; ++i) {
		if (map[row][i] == map[row][i + 1]) {
			if (map[row][i] == "● ") {
				consecutiveBlackRow++;
			}
			else if (map[row][i] == "○ ") {
				consecutiveWhiteRow++;
			}
		}
		else {
			consecutiveBlackRow = 0;
			consecutiveWhiteRow = 0;
		}
		if (map[i][col] == map[i + 1][col]) {
			if (map[i][col] == "● ") {
				consecutiveBlackCol++;
			}
			else if (map[i][col] == "○ ") {
				consecutiveWhiteCol++;
			}
		}
		else {
			consecutiveBlackCol = 0;
			consecutiveWhiteCol = 0;
		}
	}
	lines[row].longConsecutive = max(lines[row].longConsecutive, max(consecutiveBlackRow, consecutiveWhiteRow));
	lines[ROW + col].longConsecutive = max(lines[ROW + col].longConsecutive, max(consecutiveBlackCol, consecutiveWhiteCol));
}

void printConsecutiveLine(Line lines[ROW + COL + 2]) {
	for (int i = 0; i < ROW; ++i) {
		cout << i << " : 가장 긴 연속(가로) " << lines[i].longConsecutive
			<< ", 가장 긴 연속(세로) " << lines[ROW + i].longConsecutive << '\n';
	}
	for (int i = ROW + COL; i < ROW + COL + 2; ++i) {
		cout << i - ROW - COL << " : 가장 긴 연속(대각선) " << lines[i].longConsecutive << '\n';
	}
	cout << '\n';
}

int main() {
	Line lines[ROW + COL + 2];
	int b_stone = 0, w_stone = 0;
	int row, col;
	string currentPlayer = "● ";
	string blackStone = "● ";
	string whiteStone = "○ ";

	set();
	printMap(lines);

	while (true) {
		cout << "좌표를 입력하세요 : 숫자 숫자" << '\n';
		cin >> row >> col;

		if (cin.fail()) {
			cout << "숫자를 입력해주세요" << '\n';
			cout << "\n";
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
			continue;
		}

		if (!isValidMove(map, row, col)) {
			cout << "이미 돌이 있습니다" << '\n';
			continue;
		}
		
		cout << '\n';

		placeStone(map, row, col, currentPlayer);

		countStone(lines, map, row, col);
		consecutiveStone(lines, map, row, col);
		
		printMap(lines);
		printConsecutiveLine(lines);
		currentPlayer = (currentPlayer == "● ") ? "○ " : "● ";
	}
}
